<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BioCrabs: Interactive Aquatic Life Simulation with Evolving Creatures</title>
  <style>
    html, body {
      margin:0; padding:0;
      width:100%; height:100%;
      overflow:hidden;
      font-family:sans-serif;
    }
    #worldCanvas {
      display:block;
      background:linear-gradient(to bottom, #8CD5FF, #054A91);
      position: relative;
      overflow: hidden;
    }
    /* Water ripple effect as pseudo-element */
    #worldCanvas::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        radial-gradient(rgba(255,255,255,.12), rgba(255,255,255,.05) 2px, transparent 4px),
        radial-gradient(rgba(255,255,255,.08), rgba(255,255,255,.03) 1px, transparent 3px);
      background-size:
        180px 180px,
        120px 120px;
      background-position:
        0 0,
        20px 20px;
      pointer-events: none;
      animation: waterShimmer 15s infinite linear;
    }
    @keyframes waterShimmer {
      0% {
        background-position: 0 0, 20px 20px;
      }
      100% {
        background-position: 180px 180px, 140px 140px;
      }
    }
    #worldCanvas::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.03) 50%, rgba(255,255,255,0) 100%);
      pointer-events: none;
      animation: waterGlow 8s infinite ease-in-out;
    }
    @keyframes waterGlow {
      0%, 100% {
        opacity: 0.6;
      }
      50% {
        opacity: 1;
      }
    }
    #breedBtn {
      position:absolute; bottom:16px; left:50%;
      transform:translateX(-50%);
      padding:12px 24px;
      font-size:1em;
      cursor:pointer;
      background:linear-gradient(to bottom, #4b6cb7, #182848);
      color:white;
      border:none; border-radius:6px;
      transition:all 0.3s ease;
      display:none;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    #breedBtn:hover {
      background:linear-gradient(to bottom, #5d7ec9, #263b67);
      transform:translateX(-50%) scale(1.05);
    }
    #infoPanel {
      position:absolute; top:16px; right:16px;
      background:rgba(9,24,51,0.75); color:white;
      padding:12px; border-radius:8px;
      font-size:0.9em;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25);
      backdrop-filter: blur(5px);
      max-width: 280px;
      transition: all 0.3s ease;
    }
    #infoPanel:hover {
      background:rgba(9,24,51,0.85);
    }
  </style>
</head>
<body>

<canvas id="worldCanvas"></canvas>
<button id="breedBtn">Breed Next Generation</button>
<div id="infoPanel">Click crabs to select (min 2 to breed)</div>

<script>
"use strict";

/***********************************************************************
 * 1) EXTRACT REPETITIVE LOGIC INTO FUNCTIONS (DRY Strategy)
 ***********************************************************************/

/** 
 * Helper: Start a polygon path from a set of vertices 
 * and close it automatically.
 */
function beginPolygonPath(ctx, vertices) {
  ctx.beginPath();
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 1; i < vertices.length; i++) {
    ctx.lineTo(vertices[i].x, vertices[i].y);
  }
  ctx.closePath();
}

/**
 * Helper: Create a radial gradient with an array of color stops.
 * Each stop: { offset: number, color: string }
 */
function createRadialGradient(ctx, x, y, innerR, outerR, stops) {
  const grad = ctx.createRadialGradient(x, y, innerR, x, y, outerR);
  stops.forEach(stop => {
    grad.addColorStop(stop.offset, stop.color);
  });
  return grad;
}

/**
 * Helper: Fill an arc with a specified gradient.
 * This avoids repeating the same beginPath/arc/fill pattern.
 */
function fillArcWithGradient(ctx, x, y, radius, gradient) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();
}

/**
 * Helper: Fill a polygon from the given vertices using a fillStyle.
 */
function fillPolygon(ctx, vertices, fillStyle) {
  beginPolygonPath(ctx, vertices);
  ctx.fillStyle = fillStyle;
  ctx.fill();
}

/**
 * Helper: Stroke a polygon from the given vertices using a strokeStyle/lineWidth.
 */
function strokePolygon(ctx, vertices, strokeStyle, lineWidth = 1) {
  beginPolygonPath(ctx, vertices);
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = strokeStyle;
  ctx.stroke();
}


/***********************************************************************
 * CONFIG - JIRA TICKET CHANGES
 ***********************************************************************/
const CONFIG = {
  POP_SIZE: 10,
  LIMB_COUNT: 8,
  BRANCH_DEPTH: 2,
  MUTATION_RATE: 0.1,

  CRAB_RADIUS: 30,
  TIME_STEP: 0.1,
  LIMB_ANGLE_LIMIT: 5*Math.PI/6,

  // stroke logic - base values, modified by genes
  POWER_FACTOR: 1.0,
  RECOVERY_FACTOR: 0.2,

  // base drag, modified by genes
  DRAG_COEFF: 0.002,
  ROT_DRAG: 0.01,

  // base elasticity, modified by genes
  RESTITUTION: 0.5,
  COLLISION_REPULSION: 0.5,

  // inertia calculation
  INERTIA_FACTOR: 0.005,

  // base torque values, modified by genes
  TORQUE_MULTIPLIER: 20.0,
  COLLISION_TORQUE_FACTOR: 120.0,
  
  // whirlpool (gravity center) parameters
  GRAVITY_STRENGTH: 0.4,
  GRAVITY_RADIUS: 45,
  GRAVITY_VISUAL_PULSE: 0.3,
  GRAVITY_FALLOFF: 350,
  
  // Water spider movement parameters
  SURFACE_TENSION: 0.7,
  SKITTER_FACTOR: 0.25,
  RIPPLE_EFFECT: 0.15,
  PULSE_INTERVAL: 5.0,
  WATER_RESISTANCE: 1.2
};

/***********************************************************************
 * GLOBALS
 ***********************************************************************/
let canvas, ctx, W, H;
let population=[];
let globalTime=0;

/***********************************************************************
 * UTILS
 ***********************************************************************/
const Utils = {
  clamp(x,lo,hi){ return Math.max(lo, Math.min(hi,x)); },
  rand(min=0,max=1){ return Math.random()*(max-min)+min; },
  crossover(a,b){ 
    let child = [];
    for (let i = 0; i < a.length; i++) {
      child[i] = Math.random() < 0.5 ? a[i] : b[i];
    }
    // Handle color genes separately
    child[this.GENE.COLOR_R] = Math.random() < 0.5 ? a[this.GENE.COLOR_R] : b[this.GENE.COLOR_R];
    child[this.GENE.COLOR_G] = Math.random() < 0.5 ? a[this.GENE.COLOR_G] : b[this.GENE.COLOR_G];
    child[this.GENE.COLOR_B] = Math.random() < 0.5 ? a[this.GENE.COLOR_B] : b[this.GENE.COLOR_B];
    return child;
  },

  getPolyVerts(n, r, elong, orient){
    let arr=[];
    for(let i=0;i<n;i++){
      let angle= orient+ 2*Math.PI*(i/n);
      arr.push({ x:r*Math.cos(angle), y:r*Math.sin(angle)* elong });
    }
    return arr;
  },
  getAttach(verts, frac){
    let edges=[], total=0;
    for(let i=0;i<verts.length;i++){
      let v1=verts[i], v2=verts[(i+1)%verts.length];
      let dx= v2.x- v1.x, dy= v2.y- v1.y;
      let dist= Math.sqrt(dx*dx+ dy*dy);
      edges.push({v1,v2,dist});
      total+= dist;
    }
    let targ= frac* total, acc=0;
    for(let e of edges){
      if(acc+ e.dist>= targ){
        let leftover= targ- acc;
        let portion= leftover/e.dist;
        return {
          x: e.v1.x+ portion*( e.v2.x- e.v1.x),
          y: e.v1.y+ portion*( e.v2.y- e.v1.y)
        };
      }
      acc+= e.dist;
    }
    return verts[0];
  },
  
  // Gene index constants
  GENE: {
    // Body genes
    RADIUS: 0,
    ELONGATION: 1,
    ORIENT: 2,
    // Derived genes (after limb genes)
    FREQ: 3 + CONFIG.LIMB_COUNT * 5,
    AMP: 4 + CONFIG.LIMB_COUNT * 5,
    // Main genes
    SIDES: 53,
    BODY_SYM: 54,
    MOVE_SYM: 55,
    COLOR_R: 56,
    COLOR_G: 57,
    COLOR_B: 58,
    ENERGY: 59,
    // New genes
    DRAG_MOD: 60,
    ROT_DRAG_MOD: 61,
    ELASTICITY: 62, 
    TORQUE_EFF: 63,
    POWER_RATIO: 64
  },
  
  getGene(genotype, gene, fallback=1.0) {
    return genotype[gene] !== undefined ? genotype[gene] : fallback;
  },
  getFormattedGene(genotype, gene, fallback=1.0) {
    const value = this.getGene(genotype, gene, fallback);
    return Math.round(value * 100) / 100;
  }
};

/***********************************************************************
 * ON LOAD
 ***********************************************************************/
window.addEventListener("load", ()=>{
  canvas= document.getElementById("worldCanvas");
  ctx= canvas.getContext("2d");
  window.addEventListener("resize", resize);
  resize();

  document.getElementById("breedBtn").onclick= breedNextGeneration;
  canvas.addEventListener("click", onCanvasClick);

  initPopulation();
  requestAnimationFrame(mainLoop);
});
function resize(){
  W= window.innerWidth; 
  H= window.innerHeight;
  canvas.width= W;
  canvas.height= H;
}

/***********************************************************************
 * GENETICS
 ***********************************************************************/
function createRandomGenotype(){
  const LC = CONFIG.LIMB_COUNT;
  let g = [];
  const geneCount = 3 + (LC*5) + 2 + LC + 1 + 2 + 3 + 1 + 5;

  // Initialize array
  for (let i = 0; i < geneCount; i++) {
    g[i] = 0;
  }

  // Body genes
  g[Utils.GENE.RADIUS] = Utils.rand(15, 30);
  g[Utils.GENE.ELONGATION] = Utils.rand(0.7, 1.3);
  g[Utils.GENE.ORIENT] = Utils.rand(0, 2*Math.PI);

  // Limb genes
  for (let i = 0; i < LC; i++) {
    let base = 3 + i*5;
    g[base] = Utils.rand(0, 2*Math.PI);
    g[base+1] = Utils.rand(10, 40);
    g[base+2] = Utils.rand(0.1, 0.7);
    g[base+3] = Utils.rand(0.5, 0.9);
    g[base+4] = Utils.rand(0, 2*Math.PI);
  }
  
  // Frequency and amplitude
  g[Utils.GENE.FREQ] = Utils.rand(1, 3);
  g[Utils.GENE.AMP] = Utils.rand(0.2, 1);

  // Attach fraction
  for (let i = 0; i < LC; i++) {
    g[45 + i] = Math.random();
  }
  
  // Shape and symmetry
  g[Utils.GENE.SIDES] = Math.floor(Utils.rand(3, 9));
  g[Utils.GENE.BODY_SYM] = Utils.rand(0, 0.4);
  g[Utils.GENE.MOVE_SYM] = 0;
  
  // Color
  g[Utils.GENE.COLOR_R] = Utils.rand(0, 255);
  g[Utils.GENE.COLOR_G] = Utils.rand(0, 255);
  g[Utils.GENE.COLOR_B] = Utils.rand(0, 255);
  
  // Energy
  g[Utils.GENE.ENERGY] = Utils.rand(0, 10);
  
  // Physical traits
  g[Utils.GENE.DRAG_MOD] = Utils.rand(0.5, 1.5);
  g[Utils.GENE.ROT_DRAG_MOD] = Utils.rand(0.7, 1.3);
  g[Utils.GENE.ELASTICITY] = Utils.rand(0.8, 1.2);
  g[Utils.GENE.TORQUE_EFF] = Utils.rand(0.8, 1.2);
  g[Utils.GENE.POWER_RATIO] = Utils.rand(0.8, 1.5);

  return g;
}

function mutate(g, mutationRate=CONFIG.MUTATION_RATE){
  const LC = CONFIG.LIMB_COUNT;
  
  for(let i=0; i<g.length; i++){
    if(Math.random() < mutationRate){
      // Color genes can change more dramatically
      if (i === Utils.GENE.COLOR_R || i === Utils.GENE.COLOR_G || i === Utils.GENE.COLOR_B) {
        g[i] += Utils.rand(-50, 50);
      } else {
        g[i] *= (1 + Utils.rand(-0.2, 0.2));
      }
    }
  }
  
  // Clamps
  g[Utils.GENE.SIDES] = Utils.clamp(Math.round(g[Utils.GENE.SIDES]), 3, 8);
  g[Utils.GENE.BODY_SYM] = Utils.clamp(g[Utils.GENE.BODY_SYM], 0, 1);
  g[Utils.GENE.MOVE_SYM] = Utils.clamp(g[Utils.GENE.MOVE_SYM], 0, 1);
  g[Utils.GENE.COLOR_R] = Utils.clamp(g[Utils.GENE.COLOR_R], 0, 255);
  g[Utils.GENE.COLOR_G] = Utils.clamp(g[Utils.GENE.COLOR_G], 0, 255);
  g[Utils.GENE.COLOR_B] = Utils.clamp(g[Utils.GENE.COLOR_B], 0, 255);
  g[Utils.GENE.ENERGY] = Utils.clamp(g[Utils.GENE.ENERGY], 0, 10);
  
  g[Utils.GENE.DRAG_MOD] = Utils.clamp(g[Utils.GENE.DRAG_MOD], 0.5, 1.5);
  g[Utils.GENE.ROT_DRAG_MOD] = Utils.clamp(g[Utils.GENE.ROT_DRAG_MOD], 0.7, 1.3);
  g[Utils.GENE.ELASTICITY] = Utils.clamp(g[Utils.GENE.ELASTICITY], 0.8, 1.2);
  g[Utils.GENE.TORQUE_EFF] = Utils.clamp(g[Utils.GENE.TORQUE_EFF], 0.8, 1.2);
  g[Utils.GENE.POWER_RATIO] = Utils.clamp(g[Utils.GENE.POWER_RATIO], 0.8, 1.5);

  g[Utils.GENE.FREQ] = Math.max(g[Utils.GENE.FREQ], 1);
  g[Utils.GENE.AMP] = Math.max(g[Utils.GENE.AMP], 0.5);

  for(let i=0; i<LC; i++){
    let base = 3 + i*5;
    g[base+1] = Math.max(g[base+1], 1);
    g[base+2] = Utils.clamp(g[base+2], 0.05, 1);
    g[base+3] = Utils.clamp(g[base+3], 0.1, 0.95);
  }
}

function applyBodySymmetry(g){
  const LC = CONFIG.LIMB_COUNT;
  let sf = Utils.clamp(g[Utils.GENE.BODY_SYM], 0, 1);
  if (sf <= 0) return;
  
  let half = LC / 2;
  for (let i = 0; i < half; i++) {
    let L = 3 + i * 5, R = 3 + (i + half) * 5;
    let lAng = g[L];
    let lLen = g[L + 1];
    let lBrA = g[L + 2];
    let lRat = g[L + 3];
    let rAng = g[R];
    let rLen = g[R + 1];
    let rBrA = g[R + 2];
    let rRat = g[R + 3];
    let lMir = -lAng;
    
    g[R]   = sf * lMir + (1 - sf) * rAng;
    g[R+1] = sf * lLen + (1 - sf) * rLen;
    g[R+2] = sf * lBrA + (1 - sf) * rBrA;
    g[R+3] = sf * lRat + (1 - sf) * rRat;

    let la = g[45 + i], ra = g[45 + (i + half)];
    let laMir = 1 - la;
    g[45 + (i + half)] = sf * laMir + (1 - sf) * ra;
  }
}

function applyMovementSymmetry(g){
  const LC = CONFIG.LIMB_COUNT;
  let msf = Utils.clamp(g[Utils.GENE.MOVE_SYM], 0, 1);
  if (msf <= 0) return;
  
  let half = LC / 2;
  for (let i = 0; i < half; i++) {
    let L = 3 + i * 5, R = 3 + (i + half) * 5;
    let lPh = g[L + 4], rPh = g[R + 4];
    g[R + 4] = msf * lPh + (1 - msf) * rPh;
  }
}

function getSymmetricGenotype(orig){
  let copy= orig.slice();
  applyBodySymmetry(copy);
  applyMovementSymmetry(copy);
  return copy;
}

/***********************************************************************
 * POPULATION
 ***********************************************************************/
function initPopulation(){
  population=[];
  for(let i=0;i< CONFIG.POP_SIZE;i++){
    let geno= createRandomGenotype();
    let crab = {
      genotype: geno,
      x: Math.random()*W,
      y: Math.random()*H,
      vx:0, vy:0,
      orientation: Math.random()* 2*Math.PI,
      omega:0,
      selected:false
    };
    createCrabPattern(crab);
    population.push(crab);
  }
  updateBreedButton();
}

// Patterns for each crab
function createCrabPattern(crab) {
  const g = crab.genotype;
  let colR = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_R)), 0, 255);
  let colG = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_G)), 0, 255);
  let colB = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_B)), 0, 255);
  
  let dragMod = Utils.getGene(g, Utils.GENE.DRAG_MOD);
  let elasticity = Utils.getGene(g, Utils.GENE.ELASTICITY);
  let rad = Utils.getGene(g, Utils.GENE.RADIUS);
  let sides = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.SIDES)), 3, 8);

  let colorIntensity = 0.8 + 0.4 * (elasticity - 0.8) / 0.4;

  const patternCanvas = document.createElement('canvas');
  const patternSize = Math.max(rad * 2, 100);
  patternCanvas.width = patternSize;
  patternCanvas.height = patternSize;
  const patternCtx = patternCanvas.getContext('2d');
  
  patternCtx.fillStyle = `rgb(${Math.min(255, colR * colorIntensity)},
                             ${Math.min(255, colG * colorIntensity)},
                             ${Math.min(255, colB * colorIntensity)})`;
  patternCtx.fillRect(0, 0, patternSize, patternSize);
  
  const patternDensity = Math.min(30, sides * 4);
  const patternOpacity = 0.1 + 0.1 * dragMod;
  
  for (let i = 0; i < patternDensity; i++) {
    const px = Math.random() * patternSize;
    const py = Math.random() * patternSize;
    const patternElementSize = 2 + Math.random() * 4;
    
    patternCtx.beginPath();
    patternCtx.arc(px, py, patternElementSize, 0, Math.PI * 2);
    patternCtx.fillStyle = `rgba(${colR * 0.7}, ${colG * 0.7}, ${colB * 0.7}, ${patternOpacity})`;
    patternCtx.fill();
  }
  
  for (let i = 0; i < patternDensity/2; i++) {
    const px = Math.random() * patternSize;
    const py = Math.random() * patternSize;
    const highlightSize = 1 + Math.random() * 2;
    
    patternCtx.beginPath();
    patternCtx.arc(px, py, highlightSize, 0, Math.PI * 2);
    patternCtx.fillStyle = `rgba(255, 255, 255, ${0.1 + 0.1 * elasticity})`;
    patternCtx.fill();
  }

  crab.pattern = ctx.createPattern(patternCanvas, 'repeat');
  crab._patternInfo = {
    colR, colG, colB, 
    dragMod, elasticity, sides
  };
}

function breedNextGeneration(){
  let chosen = population.filter(c => c.selected);
  if(chosen.length < 2) return;
  
  chosen.forEach(crab => {
    const dragFitness = 1.2 - Utils.getGene(crab.genotype, Utils.GENE.DRAG_MOD);
    const torqueFitness = Utils.getGene(crab.genotype, Utils.GENE.TORQUE_EFF);
    const powerFitness = Utils.getGene(crab.genotype, Utils.GENE.POWER_RATIO);
    crab._fitness = (dragFitness + torqueFitness * 1.2 + powerFitness) / 3.2;
  });
  
  chosen.sort((a, b) => b._fitness - a._fitness);
  
  let newPop = [];
  
  const eliteCount = Math.min(2, chosen.length);
  for (let i = 0; i < eliteCount; i++) {
    let crab = {
      genotype: [...chosen[i].genotype],
      x: Math.random() * W,
      y: Math.random() * H,
      vx: 0, vy: 0,
      orientation: Math.random() * 2 * Math.PI,
      omega: 0,
      selected: false
    };
    createCrabPattern(crab);
    newPop.push(crab);
  }
  
  while (newPop.length < CONFIG.POP_SIZE) {
    let parent1, parent2;
    const tournamentSize = Math.min(3, chosen.length);
    let candidates = [];
    for (let i = 0; i < tournamentSize; i++) {
      candidates.push(chosen[Math.floor(Math.random() * chosen.length)]);
    }
    candidates.sort((a, b) => b._fitness - a._fitness); 
    parent1 = candidates[0].genotype;
    
    candidates = [];
    for (let i = 0; i < tournamentSize; i++) {
      candidates.push(chosen[Math.floor(Math.random() * chosen.length)]);
    }
    candidates.sort((a, b) => b._fitness - a._fitness);
    parent2 = candidates[0].genotype;
    
    let child = Utils.crossover(parent1, parent2);
    mutate(child, CONFIG.MUTATION_RATE);
    
    let crab = {
      genotype: child,
      x: Math.random() * W,
      y: Math.random() * H,
      vx: 0, vy: 0,
      orientation: Math.random() * 2 * Math.PI,
      omega: 0,
      selected: false
    };
    createCrabPattern(crab);
    newPop.push(crab);
  }
  
  population = newPop;
  updateBreedButton();
}

/***********************************************************************
 * SWIM MOVEMENT + COLLISIONS
 ***********************************************************************/
function updateMovement(){
  for(let crab of population){
    applyLimbForces(crab);
    applyQuadraticDrag(crab);
    applyGravityForce(crab);
  }
  for(let i=0;i< population.length; i++){
    for(let j=i+1;j< population.length;j++){
      handleCrabCollision(population[i], population[j]);
    }
  }
  for(let crab of population){
    integrateCrab(crab);
    handleWallCollision(crab);
  }
}

function applyLimbForces(crab){
  const LC= CONFIG.LIMB_COUNT;
  crab._fx=0; 
  crab._fy=0;
  crab._torque=0;

  let rad= Utils.getGene(crab.genotype, Utils.GENE.RADIUS);
  crab._inertia= 1 + CONFIG.INERTIA_FACTOR * (rad * rad);

  let freq= Utils.getGene(crab.genotype, Utils.GENE.FREQ);
  let amp = Utils.getGene(crab.genotype, Utils.GENE.AMP);
  
  let powerRatio = Utils.getGene(crab.genotype, Utils.GENE.POWER_RATIO);
  let torqueEfficiency = Utils.getGene(crab.genotype, Utils.GENE.TORQUE_EFF);

  const pulsePhase = (globalTime % CONFIG.PULSE_INTERVAL) / CONFIG.PULSE_INTERVAL;
  const pulseFactor = Math.pow(Math.sin(pulsePhase * Math.PI), 2);
  
  const currentSpeed = Math.sqrt(crab.vx * crab.vx + crab.vy * crab.vy);
  
  const skitterOffset = rad * 0.1;
  const skitterPhase = Math.sin(globalTime * 3 + skitterOffset) * CONFIG.SKITTER_FACTOR;
  
  const surfaceTensionFactor = CONFIG.SURFACE_TENSION / (1 + currentSpeed * 0.5);
  
  for(let i=0;i<LC;i++){
    let base= 3+ i*5;
    let bAng= crab.genotype[base+0];
    let limbLen= crab.genotype[base+1];
    let phase= crab.genotype[base+4];

    let cyc= freq*globalTime+ phase;
    let cycMod= cyc % (2*Math.PI);
    let inPower= (cycMod>=0 && cycMod<Math.PI);
    let rawSine= amp* Math.sin(cycMod + skitterPhase);

    let powerFactor = inPower 
      ? CONFIG.POWER_FACTOR * powerRatio * (1 + surfaceTensionFactor) 
      : CONFIG.RECOVERY_FACTOR;
    if (inPower) {
      powerFactor *= (1 + pulseFactor * 0.8);
    }
    
    let thrust= powerFactor * Math.abs(rawSine) * (limbLen/40);
    const rippleEffect = Math.abs(Math.sin(cycMod * 0.5)) * CONFIG.RIPPLE_EFFECT;
    if (inPower && Math.sin(cycMod) > 0.7) {
      thrust *= (1 + rippleEffect);
    }

    let dir= crab.orientation+ bAng + Math.PI;
    let fx= thrust* Math.cos(dir);
    let fy= thrust* Math.sin(dir);

    crab._fx+= fx; 
    crab._fy+= fy;

    let offR= rad * (0.6 + 0.4 * Math.abs(Math.sin(bAng)));
    let offX= offR* Math.cos(crab.orientation+ bAng);
    let offY= offR* Math.sin(crab.orientation+ bAng);
    let torqueContribution = (offX* fy - offY* fx);

    const rotationSkitter = 0.1 * Math.sin(globalTime * 2 + i) * CONFIG.SKITTER_FACTOR;
    let phaseEffect = (0.05 + rotationSkitter) * Math.sin(cycMod + bAng) * thrust;
    crab._torque += (torqueContribution + phaseEffect) * torqueEfficiency;
  }
}

function applyQuadraticDrag(crab){
  let dragMod = Utils.getGene(crab.genotype, Utils.GENE.DRAG_MOD);
  let rotDragMod = Utils.getGene(crab.genotype, Utils.GENE.ROT_DRAG_MOD);
  
  let vx = crab.vx, vy = crab.vy;
  let s2 = vx*vx + vy*vy;
  
  if(s2 > 0){
    let s = Math.sqrt(s2);
    const waterResistanceFactor = CONFIG.WATER_RESISTANCE * (1.5 / (1 + s));
    let baseDragMag = CONFIG.DRAG_COEFF * dragMod * s2 * waterResistanceFactor;
    
    let crabAngle = crab.orientation;
    let moveAngle = Math.atan2(vy, vx);
    let angleDiff = Math.abs((moveAngle - crabAngle + Math.PI) % (2 * Math.PI) - Math.PI);
    
    let directionFactor = 0.7 + 0.6 * (angleDiff / Math.PI);
    let dragMag = baseDragMag * directionFactor;
    
    crab._fx += -dragMag * (vx/s);
    crab._fy += -dragMag * (vy/s);
    
    if (s > 3 && angleDiff > 0.3) {
      let alignmentTorque = 0.03 * Math.sin(moveAngle - crabAngle) * s * dragMod;
      crab._torque += alignmentTorque;
    }
    
    if (s < 5) {
      const skitterFreq = 3.0 + s;
      const skitterMag = 0.02 * (5 - s) / 5;
      crab._fx += skitterMag * Math.sin(globalTime * skitterFreq) * s;
      crab._fy += skitterMag * Math.cos(globalTime * skitterFreq + 0.4) * s;
    }
  }
  
  let omegaSq = crab.omega * crab.omega;
  let rotDrag = CONFIG.ROT_DRAG * rotDragMod * (1 + 0.15 * omegaSq);
  crab._torque += -rotDrag * crab.omega;
}

function applyGravityForce(crab) {
  let dx = W/2 - crab.x;
  let dy = H/2 - crab.y;
  let distSq = dx*dx + dy*dy;
  let dist = Math.sqrt(distSq) || 0.0001;
  
  if (dist > CONFIG.GRAVITY_FALLOFF) return;
  
  let gravityFactor = 1 - (dist / CONFIG.GRAVITY_FALLOFF);
  gravityFactor = Math.max(0, gravityFactor * gravityFactor);
  
  // Add vortex/whirlpool effect - stronger closer to center
  const vortexStrength = 0.3 * gravityFactor * gravityFactor;
  const vortexAngle = Math.atan2(dy, dx) + Math.PI/2;
  
  let vortexFx = Math.cos(vortexAngle) * vortexStrength;
  let vortexFy = Math.sin(vortexAngle) * vortexStrength;
  
  // Direct pull toward center
  let nx = dx / dist;
  let ny = dy / dist;
  
  crab._fx += nx * CONFIG.GRAVITY_STRENGTH * gravityFactor;
  crab._fy += ny * CONFIG.GRAVITY_STRENGTH * gravityFactor;
  
  // Apply vortex forces
  crab._fx += vortexFx;
  crab._fy += vortexFy;
  
  // Apply torque to match the vortex spin direction
  let angleToCenter = Math.atan2(dy, dx);
  let angleDiff = angleToCenter - crab.orientation;
  angleDiff = (angleDiff + Math.PI) % (2 * Math.PI) - Math.PI;
  
  // Add a spiraling spin effect
  const spinTorque = 0.05 * gravityFactor * gravityFactor;
  
  crab._torque += 0.03 * Math.sin(angleDiff) * gravityFactor + spinTorque;
}

function handleCrabCollision(A, B) {
  let dx = B.x - A.x, dy = B.y - A.y;
  let distSq = dx*dx + dy*dy;
  let minDist = CONFIG.CRAB_RADIUS * 2;
  if (distSq >= minDist * minDist) return;
  
  let dist = Math.sqrt(distSq) || 0.0001;
  let overlap = minDist - dist;
  let nx = dx / dist, ny = dy / dist;
  
  let relPosAx = CONFIG.CRAB_RADIUS * nx;
  let relPosAy = CONFIG.CRAB_RADIUS * ny;
  let relPosBx = -CONFIG.CRAB_RADIUS * nx;
  let relPosBy = -CONFIG.CRAB_RADIUS * ny;
  
  let rvx = B.vx + (-B.omega * relPosBy) - (A.vx + (-A.omega * relPosAy));
  let rvy = B.vy + (B.omega * relPosBx) - (A.vy + (A.omega * relPosAx));
  let approach = rvx * nx + rvy * ny;
  
  if (approach < 0) {
    let elasticityA = Utils.getGene(A.genotype, Utils.GENE.ELASTICITY);
    let elasticityB = Utils.getGene(B.genotype, Utils.GENE.ELASTICITY);
    let avgElasticity = (elasticityA + elasticityB) / 2;
    
    let e = CONFIG.RESTITUTION * avgElasticity;
    let j = -(1 + e) * approach * 0.5;
    let impx = j * nx, impy = j * ny;

    A.vx -= impx; A.vy -= impy;
    B.vx += impx; B.vy += impy;

    let cAx = A.x + CONFIG.CRAB_RADIUS * nx;
    let cAy = A.y + CONFIG.CRAB_RADIUS * ny;
    let cBx = B.x - CONFIG.CRAB_RADIUS * nx;
    let cBy = B.y - CONFIG.CRAB_RADIUS * ny;

    let offAx = cAx - A.x, offAy = cAy - A.y;
    let torqueA = offAx * (-impy) - offAy * (-impx);
    let glancingFactorA = 1.0 - Math.abs(nx * dx + ny * dy) / dist;
    torqueA *= (1.0 + glancingFactorA);
    A.omega -= (torqueA * CONFIG.COLLISION_TORQUE_FACTOR) / (A._inertia || 1);

    let offBx = cBx - B.x, offBy = cBy - B.y;
    let torqueB = offBx * impy - offBy * impx;
    let glancingFactorB = glancingFactorA;
    torqueB *= (1.0 + glancingFactorB);
    B.omega += (torqueB * CONFIG.COLLISION_TORQUE_FACTOR) / (B._inertia || 1);
    
    createCollisionEffect((cAx + cBx) / 2, (cAy + cBy) / 2, j, avgElasticity);
  }
  
  let push = CONFIG.COLLISION_REPULSION * overlap * 0.5;
  A.x -= push * nx; A.y -= push * ny;
  B.x += push * nx; B.y += push * ny;
}

/***********************************************************************
 * 2) CONSOLIDATE COLLISION EFFECTS INTO A SINGLE ARRAY
 ***********************************************************************/
const collisionEffects = [];

/** Create a visual effect at collision point */
function createCollisionEffect(x, y, intensity, elasticity) {
  const minIntensity = 0.2;
  if (intensity < minIntensity) return;
  
  const size = Math.min(30, 5 + intensity * 3);
  const lifespan = Math.min(1.0, 0.3 + intensity * 0.04 + elasticity * 0.2);
  
  const particleCount = Math.floor(3 + intensity * 0.5);
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2 * intensity;
    const particleSize = 2 + Math.random() * 3;
    const lifetime = 0.5 + Math.random() * 0.5 * lifespan;
    
    collisionEffects.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: particleSize,
      life: lifetime,
      maxLife: lifetime,
      type: 'particle'
    });
  }
  
  // Ripple wave
  collisionEffects.push({
    x, y,
    size: size * 0.5,
    maxSize: size * 3,
    life: lifespan,
    maxLife: lifespan,
    type: 'ripple',
    intensity,
    elasticity
  });
  
  // Flash
  collisionEffects.push({
    x, y,
    size,
    life: lifespan * 0.3,
    maxLife: lifespan * 0.3,
    type: 'flash',
    intensity
  });
}

/** Update and draw collision effects */
function updateCollisionEffects() {
  for (let i = collisionEffects.length - 1; i >= 0; i--) {
    const effect = collisionEffects[i];
    effect.life -= CONFIG.TIME_STEP;
    
    if (effect.life <= 0) {
      collisionEffects.splice(i, 1);
      continue;
    }
    
    if (effect.type === 'particle') {
      effect.x += effect.vx * CONFIG.TIME_STEP;
      effect.y += effect.vy * CONFIG.TIME_STEP;
      effect.vx *= 0.95;
      effect.vy *= 0.95;
    } 
    if (effect.type === 'ripple') {
      effect.size += (effect.maxSize - effect.size) * CONFIG.TIME_STEP * 3;
    }
  }
  
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  
  for (const effect of collisionEffects) {
    const lifeFactor = effect.life / effect.maxLife;
    if (effect.type === 'particle') {
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.size * lifeFactor, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${lifeFactor * 0.7})`;
      ctx.fill();
    } 
    else if (effect.type === 'ripple') {
      const gradient = ctx.createRadialGradient(
        effect.x, effect.y, 0,
        effect.x, effect.y, effect.size
      );
      const hue = 180 + 40 * (effect.elasticity - 1);
      gradient.addColorStop(0, `hsla(${hue}, 80%, 70%, 0)`);
      gradient.addColorStop(0.3, `hsla(${hue}, 80%, 70%, ${lifeFactor * 0.2})`);
      gradient.addColorStop(0.7, `hsla(${hue}, 70%, 60%, ${lifeFactor * 0.1})`);
      gradient.addColorStop(1, `hsla(${hue}, 60%, 50%, 0)`);

      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
      ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${lifeFactor * 0.3})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    } 
    else if (effect.type === 'flash') {
      const gradient = ctx.createRadialGradient(
        effect.x, effect.y, 0,
        effect.x, effect.y, effect.size
      );
      gradient.addColorStop(0, `rgba(255, 255, 255, ${lifeFactor * 0.8})`);
      gradient.addColorStop(0.5, `rgba(200, 220, 255, ${lifeFactor * 0.4})`);
      gradient.addColorStop(1, `rgba(150, 180, 255, 0)`);

      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }
  ctx.restore();
}

function integrateCrab(crab){
  let dt= CONFIG.TIME_STEP;
  
  let torqueEfficiency = Utils.getGene(crab.genotype, Utils.GENE.TORQUE_EFF);
  let torque= crab._torque * CONFIG.TORQUE_MULTIPLIER * torqueEfficiency;
  
  let speedFactor = Math.min(1, Math.sqrt(crab.vx*crab.vx + crab.vy*crab.vy) / 10);
  torque *= (0.7 + 0.3 * speedFactor);
  
  let alpha= torque / (crab._inertia||1);

  crab.vx+= crab._fx* dt;
  crab.vy+= crab._fy* dt;
  crab.omega+= alpha* dt;
  
  let omegaLimit = 8;
  if (Math.abs(crab.omega) > omegaLimit) {
    crab.omega = Math.sign(crab.omega) * omegaLimit;
  }

  crab.x+= crab.vx* dt;
  crab.y+= crab.vy* dt;
  crab.orientation+= crab.omega* dt;
  crab.orientation = crab.orientation % (2 * Math.PI);
}

function handleWallCollision(crab){
  let e = CONFIG.RESTITUTION;
  let elasticity = Utils.getGene(crab.genotype, Utils.GENE.ELASTICITY);
  const waterEdgeEffect = 0.7; 
  e *= waterEdgeEffect * elasticity;
  
  if(crab.x < 0){
    crab.x = 0;
    if(crab.vx < 0) {
      const deflection = Utils.rand(-0.2, 0.2) * Math.abs(crab.vx);
      crab.vy += deflection;
      crab.vx = -e * crab.vx;
    }
  } else if(crab.x > W){
    crab.x = W;
    if(crab.vx > 0) {
      const deflection = Utils.rand(-0.2, 0.2) * Math.abs(crab.vx);
      crab.vy += deflection;
      crab.vx = -e * crab.vx;
    }
  }
  if(crab.y < 0){
    crab.y = 0;
    if(crab.vy < 0) {
      const deflection = Utils.rand(-0.2, 0.2) * Math.abs(crab.vy);
      crab.vx += deflection;
      crab.vy = -e * crab.vy;
    }
  } else if(crab.y > H){
    crab.y = H;
    if(crab.vy > 0) {
      const deflection = Utils.rand(-0.2, 0.2) * Math.abs(crab.vy);
      crab.vx += deflection;
      crab.vy = -e * crab.vy;
    }
  }
  
  if(crab.x <= 0 || crab.x >= W || crab.y <= 0 || crab.y >= H) {
    crab.omega += Utils.rand(-0.2, 0.2);
    
    const intensity = Math.min(Math.sqrt(crab.vx*crab.vx + crab.vy*crab.vy) * 0.2, 0.5);
    if(intensity > 0.1) {
      let contactX = crab.x;
      let contactY = crab.y;
      if(crab.x <= 0) contactX = 0;
      if(crab.x >= W) contactX = W;
      if(crab.y <= 0) contactY = 0;
      if(crab.y >= H) contactY = H;
      
      createCollisionEffect(contactX, contactY, intensity, elasticity);
    }
  }
}

/***********************************************************************
 * DRAW
 ***********************************************************************/
function drawBranch(ctx, length, angle, ratio, depth, geneInfo) {
  const { torqueEff, dragMod, powerRatio } = geneInfo || {};
  
  if (depth < 1 || length < 2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    
    const cp1x = length * 0.3;
    const cp1y = length * 0.05 * Math.sin(globalTime + depth);
    const cp2x = length * 0.7;
    const cp2y = length * 0.03 * Math.sin(globalTime * 0.8 + depth);
    
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, length, 0);
    const alpha = 0.8 - (depth * 0.1);
    ctx.strokeStyle = `rgba(30, 40, 50, ${alpha})`;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(length, 0, Math.max(0.3, length * 0.03), 0, Math.PI * 2);
    ctx.fillStyle = `rgba(40, 50, 60, ${alpha})`;
    ctx.fill();
    
    ctx.translate(length, 0);
    return;
  }
  
  const limbGradient = ctx.createLinearGradient(0, 0, length, 0);
  limbGradient.addColorStop(0, `rgba(40, 50, 60, 0.9)`);
  limbGradient.addColorStop(1, `rgba(30, 40, 50, 0.7)`);
  
  ctx.beginPath();
  ctx.lineWidth = Math.max(1, 2 * (1 + 0.3 * (torqueEff || 1)));
  
  const cpOffset = length * 0.05 * Math.sin(globalTime * 0.3);
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(
    length * 0.3, cpOffset, 
    length * 0.7, cpOffset, 
    length, 0
  );
  
  ctx.strokeStyle = limbGradient;
  ctx.stroke();
  
  ctx.beginPath();
  const jointSize = Math.max(0.5, length * 0.04 * (dragMod || 1));
  ctx.arc(length, 0, jointSize, 0, Math.PI * 2);
  const jointR = 40 + (powerRatio ? Math.min(30, powerRatio * 20) : 0);
  const jointG = 50 + (powerRatio ? Math.min(20, powerRatio * 15) : 0);
  ctx.fillStyle = `rgb(${jointR}, ${jointG}, 60)`;
  ctx.fill();
  
  ctx.translate(length, 0);
  
  ctx.save();
  ctx.rotate(angle);
  drawBranch(ctx, length * ratio, angle, ratio, depth - 1, geneInfo);
  ctx.restore();

  ctx.save();
  ctx.rotate(-angle);
  drawBranch(ctx, length * ratio, angle, ratio, depth - 1, geneInfo);
  ctx.restore();
}

function drawEnergyDots(ctx, eVal, bodyR, color) {
  let c = Math.floor(eVal);
  if (c <= 0) return;
  
  const ring = bodyR * 0.25;
  const dotBase = bodyR * 0.07;
  
  const baseRgb = color.match(/\d+/g);
  const r = parseInt(baseRgb[0]);
  const g = parseInt(baseRgb[1]);
  const b = parseInt(baseRgb[2]);
  
  for (let i = 0; i < c; i++) {
    const angle = 2 * Math.PI * (i / c);
    const x = ring * Math.cos(angle);
    const y = ring * Math.sin(angle);
    
    const pulseRate = 0.4 + (i * 0.1);
    const pulseFactor = 1 + 0.2 * Math.sin(globalTime * pulseRate + i);
    const dotSize = dotBase * pulseFactor;
    
    const glowSize = dotSize * 2.5;
    const energyR = Math.min(255, r + 100);
    const energyG = Math.min(255, g + 50);
    const energyB = Math.min(255, b + 30);
    
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
    gradient.addColorStop(0, `rgba(${energyR}, ${energyG}, ${energyB}, 0.9)`);
    gradient.addColorStop(0.4, `rgba(${energyR}, ${energyG}, ${energyB}, 0.5)`);
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.beginPath();
    ctx.arc(x, y, glowSize, 0, 2 * Math.PI);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(x, y, dotSize, 0, 2 * Math.PI);
    ctx.fillStyle = `rgb(${energyR}, ${energyG}, ${energyB})`;
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(x - dotSize * 0.3, y - dotSize * 0.3, dotSize * 0.4, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.fill();
  }
}

function drawCrab(ctx, g, t, crabX, crabY) {
  const LC = CONFIG.LIMB_COUNT;
  let rad = Utils.getGene(g, Utils.GENE.RADIUS);
  let el = Utils.getGene(g, Utils.GENE.ELONGATION);
  let ornt = Utils.getGene(g, Utils.GENE.ORIENT);
  let freq = Utils.getGene(g, Utils.GENE.FREQ);
  let amp = Utils.getGene(g, Utils.GENE.AMP);
  let sides = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.SIDES)), 3, 8);
  
  let colR = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_R)), 0, 255);
  let colG = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_G)), 0, 255);
  let colB = Utils.clamp(Math.round(Utils.getGene(g, Utils.GENE.COLOR_B)), 0, 255);
  let color = `rgb(${colR},${colG},${colB})`;
  let energy = Utils.clamp(Utils.getGene(g, Utils.GENE.ENERGY), 0, 10);
  
  let dragMod = Utils.getGene(g, Utils.GENE.DRAG_MOD);
  let rotDragMod = Utils.getGene(g, Utils.GENE.ROT_DRAG_MOD);
  let elasticity = Utils.getGene(g, Utils.GENE.ELASTICITY);
  let torqueEff = Utils.getGene(g, Utils.GENE.TORQUE_EFF);
  let powerRatio = Utils.getGene(g, Utils.GENE.POWER_RATIO);

  let breathingFactor = 1.0 + 0.03 * Math.sin(t * 0.8);
  let wobbleFactor = 0.02 * Math.sin(t * 1.2);
  
  let bodyRotation = ornt + 0.07 * Math.sin(t * 0.5);
  
  let dx = W/2 - crabX;
  let dy = H/2 - crabY;
  let dist = Math.sqrt(dx*dx + dy*dy);
  let glowIntensity = 0;
  if (dist < CONFIG.GRAVITY_FALLOFF) {
    glowIntensity = 0.4 * (1 - dist/CONFIG.GRAVITY_FALLOFF);
  }
  
  let elongation = el * (0.8 + 0.4 * (1 - dragMod)) * breathingFactor;
  
  let verts = [];
  for (let i = 0; i < sides; i++) {
    let angle = bodyRotation + 2 * Math.PI * (i / sides);
    let radiusVariation = rad * (0.9 + 0.2 * Math.sin(angle * 3 + t * 0.5) * dragMod);
    let breathingRadius = radiusVariation * breathingFactor;
    
    verts.push({
      x: breathingRadius * Math.cos(angle) * (1 + wobbleFactor * Math.sin(angle * sides)),
      y: breathingRadius * Math.sin(angle) * elongation * (1 + wobbleFactor * Math.cos(angle * sides))
    });
  }
  
  // Shadow
  ctx.save();
  ctx.translate(3, 3);
  fillPolygon(ctx, verts, "rgba(0,0,0,0.25)");
  ctx.shadowColor = "rgba(0,0,0,0.1)";
  ctx.shadowBlur = 5;
  ctx.restore();
  
  // Reflection from gravity center
  if (glowIntensity > 0) {
    ctx.save();
    beginPolygonPath(ctx, verts);
    let reflectionColor = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
    ctx.shadowColor = reflectionColor;
    ctx.shadowBlur = 8;
    ctx.fillStyle = reflectionColor;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fill();
    
    const rippleCount = Math.floor(3 * glowIntensity);
    for (let i = 0; i < rippleCount; i++) {
      const rippleRadius = rad * (1.2 + 0.5 * i);
      const rippleOpacity = 0.1 * glowIntensity * (1 - i/rippleCount);
      ctx.beginPath();
      ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 255, 255, ${rippleOpacity})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }
  
  // Body fill
  ctx.save();
  beginPolygonPath(ctx, verts);

  // Use the cached pattern if found
  let thisCrab = null;
  for (let c of population) {
    if (c.genotype === g) {
      thisCrab = c;
      break;
    }
  }
  if (thisCrab && thisCrab.pattern) {
    ctx.fillStyle = thisCrab.pattern;
  } else {
    ctx.fillStyle = color;
  }
  ctx.fill();
  
  // Subtle gradient overlay
  const gradientOverlay = ctx.createRadialGradient(0, 0, 0, 0, 0, rad * 1.5);
  gradientOverlay.addColorStop(0, `rgba(${colR}, ${colG}, ${colB}, 0.4)`);
  gradientOverlay.addColorStop(0.7, `rgba(${colR}, ${colG}, ${colB}, 0.1)`);
  gradientOverlay.addColorStop(1, 'rgba(0, 0, 0, 0)');
  
  beginPolygonPath(ctx, verts);
  ctx.fillStyle = gradientOverlay;
  ctx.fill();
  
  // Enhanced outline
  strokePolygon(ctx, verts, 'rgba(20, 30, 40, 0.8)', 1.5 * (0.8 + 0.4 * dragMod));
  
  // Inner border
  strokePolygon(ctx, verts, `rgba(${colR * 0.5}, ${colG * 0.5}, ${colB * 0.5}, 0.3)`, 1.5 * 0.5 * (0.8 + 0.4 * dragMod));
  ctx.restore();
  
  // Limbs
  const geneInfo = { torqueEff, dragMod, elasticity, powerRatio };
  for (let i = 0; i < LC; i++) {
    let base = 3 + i * 5;
    let bAng = g[base];
    let bLen = g[base + 1];
    let brA = g[base + 2];
    let lRat = g[base + 3];
    let ph = g[base + 4];
    let aFrac = g[45 + i];
    
    let cyc = freq * t + ph;
    let swing = amp * Math.sin(cyc);
    
    let att = Utils.getAttach(verts, aFrac);
    let dx = att.x, dy = att.y;
    let angleC = Math.atan2(dy, dx);
    let rawAngle = angleC + bAng + swing;
    let delta = rawAngle - angleC;
    if (delta < -CONFIG.LIMB_ANGLE_LIMIT) delta = -CONFIG.LIMB_ANGLE_LIMIT;
    if (delta > CONFIG.LIMB_ANGLE_LIMIT) delta = CONFIG.LIMB_ANGLE_LIMIT;
    let finalA = angleC + delta;

    ctx.save();
    ctx.translate(dx, dy);
    ctx.rotate(finalA);
    
    if (Math.abs(swing) > 0.1) {
      let disturbIntensity = Math.min(0.2, 0.05 + Math.abs(swing) * 0.15 * powerRatio);
      ctx.shadowColor = `rgba(255, 255, 255, ${disturbIntensity})`;
      ctx.shadowBlur = 4;
    }
    drawBranch(ctx, bLen, brA, lRat, CONFIG.BRANCH_DEPTH, geneInfo);
    ctx.restore();
  }

  drawEnergyDots(ctx, energy, rad, color);

  // Eyes
  if (sides >= 5) {
    const eyeDistance = rad * 0.6;
    const eyeSize = rad * 0.1;
    const eyeAngle = bodyRotation + Math.PI * 0.12;
    
    const leftEyeX = Math.cos(eyeAngle) * eyeDistance;
    const leftEyeY = Math.sin(eyeAngle) * eyeDistance * elongation;
    const rightEyeX = Math.cos(-eyeAngle) * eyeDistance;
    const rightEyeY = Math.sin(-eyeAngle) * eyeDistance * elongation;
    
    const eyePulse = 1 + 0.15 * Math.sin(t * 2);
    const eyeIntensity = 0.5 + 0.5 * (energy / 10);
    const eyeR = 20 + 40 * eyeIntensity;
    const eyeG = 80 + 60 * eyeIntensity;
    const eyeB = 120 + 80 * eyeIntensity;
    
    const drawEye = (x, y) => {
      ctx.beginPath();
      ctx.arc(x, y, eyeSize * eyePulse, 0, Math.PI * 2);
      const eyeGradient = ctx.createRadialGradient(x, y, 0, x, y, eyeSize * 2);
      eyeGradient.addColorStop(0, `rgba(${eyeR}, ${eyeG}, ${eyeB}, 0.8)`);
      eyeGradient.addColorStop(0.5, `rgba(${eyeR}, ${eyeG}, ${eyeB}, 0.3)`);
      eyeGradient.addColorStop(1, 'rgba(0, 100, 200, 0)');
      ctx.fillStyle = eyeGradient;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(x, y, eyeSize * 0.4 * eyePulse, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(10, 20, 30, 0.9)`;
      ctx.fill();
    };
    drawEye(leftEyeX, leftEyeY);
    drawEye(rightEyeX, rightEyeY);
  }
}

function drawWorld(){
  ctx.clearRect(0,0,W,H);
  drawNebulaBackground();
  drawGravityCenter();
  
  updateCollisionEffects();
  
  for(let crab of population){
    let drawG = getSymmetricGenotype(crab.genotype);
    ctx.save();
    ctx.translate(crab.x, crab.y);
    ctx.rotate(crab.orientation);
    
    if(crab.selected){
      const radius = CONFIG.CRAB_RADIUS * 1.2;
      const pulseRate = 0.7 + 0.3 * Math.sin(globalTime * 2);
      const glowRadius = radius * pulseRate;
      
      const glowGradient = ctx.createRadialGradient(0, 0, radius * 0.5, 0, 0, glowRadius * 1.5);
      glowGradient.addColorStop(0, 'rgba(100, 255, 100, 0.4)');
      glowGradient.addColorStop(0.5, 'rgba(100, 255, 100, 0.2)');
      glowGradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
      
      ctx.beginPath();
      ctx.arc(0, 0, glowRadius * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = glowGradient;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      const dashLength = 15;
      const dashGap = 10;
      const dashOffset = globalTime * 30 % (dashLength + dashGap);
      
      ctx.setLineDash([dashLength, dashGap]);
      ctx.lineDashOffset = -dashOffset;
      ctx.strokeStyle = 'rgba(120, 255, 120, 0.9)';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.85, 0, Math.PI * 2);
      ctx.setLineDash([dashLength * 0.7, dashGap * 0.7]);
      ctx.lineDashOffset = dashOffset;
      ctx.strokeStyle = 'rgba(180, 255, 180, 0.7)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.setLineDash([]);
    }
    
    drawCrab(ctx, drawG, globalTime, crab.x, crab.y);
    ctx.restore();
  }
}

/** Draw the gravity center with pulsing effect */
function drawGravityCenter() {
  const centerX = W/2;
  const centerY = H/2;
  const radius = CONFIG.GRAVITY_RADIUS;
  
  let primaryPulse = 1 + 0.12 * Math.sin(globalTime * CONFIG.GRAVITY_VISUAL_PULSE);
  let secondaryPulse = 1 + 0.08 * Math.sin(globalTime * CONFIG.GRAVITY_VISUAL_PULSE * 1.5);
  let pulseRadius = radius * primaryPulse;
  
  // Original rings and glow
  for (let i = 1; i <= 5; i++) {
    const layerOpacity = 0.15 / i;
    const layerWidth = 1 + (i === 1 ? 1.2 : 0);
    const layerRadius = pulseRadius * i * (1.1 + (i * 0.05));
    const rotationOffset = globalTime * 0.05 * (i % 2 === 0 ? 1 : -1);
    
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotationOffset);
    
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const wavyRadius = layerRadius * (1 + 0.04 * Math.sin(a * 6 + globalTime * 0.2));
      const x = Math.cos(a) * wavyRadius;
      const y = Math.sin(a) * wavyRadius;
      
      if (a === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    
    ctx.strokeStyle = `rgba(255, 255, 255, ${layerOpacity})`;
    ctx.lineWidth = layerWidth;
    ctx.stroke();
    ctx.restore();
  }
  
  const glowSize = pulseRadius * 1.5 * secondaryPulse;
  const hue = (220 + Math.sin(globalTime * 0.1) * 15);
  
  const gradientInner = createRadialGradient(
    ctx,
    centerX, centerY,
    0, 
    glowSize,
    [
      { offset: 0, color: `hsla(${hue}, 80%, 80%, 0.5)` },
      { offset: 0.3, color: `hsla(${hue}, 70%, 60%, 0.3)` },
      { offset: 0.7, color: `hsla(${hue - 20}, 60%, 40%, 0.15)` },
      { offset: 1, color: 'rgba(150, 200, 255, 0)' }
    ]
  );
  
  fillArcWithGradient(ctx, centerX, centerY, glowSize, gradientInner);
  
  const coreSize = pulseRadius * 0.6;
  const coreGradient = createRadialGradient(
    ctx,
    centerX, centerY,
    0,
    coreSize,
    [
      { offset: 0, color: 'rgba(255, 255, 255, 0.8)' },
      { offset: 0.6, color: 'rgba(200, 220, 255, 0.5)' },
      { offset: 1, color: 'rgba(150, 180, 255, 0)' }
    ]
  );
  fillArcWithGradient(ctx, centerX, centerY, coreSize, coreGradient);
  
  drawWaterCurrents(centerX, centerY, pulseRadius * 3);
}

/** Draw water current particles around the gravity center */
function drawWaterCurrents(x, y, maxRadius) {
  const particleCount = 40;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  
  for (let i = 0; i < particleCount; i++) {
    const orbitSpeed = 0.1 + (i % 5) * 0.02;
    const angle = (i / particleCount) * Math.PI * 2 + globalTime * orbitSpeed;
    
    const minRadius = maxRadius * 0.2;
    const radiusRange = maxRadius * 0.8;
    const orbitRadius = minRadius + radiusRange * ((Math.sin(globalTime * 0.1 + i * 0.2) + 1) / 2);
    
    const wobble = Math.sin(globalTime * 0.5 + i) * 5;
    const px = x + Math.cos(angle) * (orbitRadius + wobble);
    const py = y + Math.sin(angle) * (orbitRadius + wobble);
    
    const baseSize = 0.8 + Math.sin(globalTime * 0.4 + i) * 0.5;
    const size = baseSize * (1 - orbitRadius/maxRadius * 0.5);
    
    const particleGradient = createRadialGradient(
      ctx, px, py,
      0, size * 2,
      [
        { offset: 0, color: `hsla(${(200 + (i*10 + globalTime*5)) % 360}, 80%, 80%, ${0.4 - orbitRadius/maxRadius * 0.3})` },
        { offset: 1, color: 'rgba(255, 255, 255, 0)' }
      ]
    );
    fillArcWithGradient(ctx, px, py, size * 2, particleGradient);
    
    if (size > 1) {
      ctx.beginPath();
      ctx.arc(px, py, size * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.fill();
    }
  }
  ctx.restore();
}

/** Subtle water surface background */
function drawNebulaBackground() {
  ctx.save();
  
  const deepWaterGradient = ctx.createLinearGradient(0, 0, 0, H);
  deepWaterGradient.addColorStop(0, 'rgba(30, 100, 180, 0.02)');
  deepWaterGradient.addColorStop(0.7, 'rgba(10, 60, 120, 0.04)');
  deepWaterGradient.addColorStop(1, 'rgba(5, 30, 80, 0.06)');
  ctx.fillStyle = deepWaterGradient;
  ctx.fillRect(0, 0, W, H);
  
  const rayCount = 5;
  const rayWidth = W / rayCount;
  ctx.globalCompositeOperation = 'lighter';
  
  for (let i = 0; i < rayCount; i++) {
    const xPos = W * (i / rayCount) + (W / (rayCount * 2));
    const rayHeight = H * 0.7;
    const rayWidthTop = rayWidth * 0.2;
    const rayWidthBottom = rayWidth * 0.7;
    const rayIntensity = 0.02 + 0.015 * Math.sin(globalTime * 0.1 + i);
    
    const rayGradient = ctx.createLinearGradient(xPos, 0, xPos, rayHeight);
    rayGradient.addColorStop(0, `rgba(255, 255, 255, ${rayIntensity})`);
    rayGradient.addColorStop(0.7, `rgba(180, 220, 255, ${rayIntensity * 0.5})`);
    rayGradient.addColorStop(1, 'rgba(100, 150, 200, 0)');
    
    ctx.beginPath();
    ctx.moveTo(xPos - rayWidthTop, 0);
    ctx.lineTo(xPos + rayWidthTop, 0);
    ctx.lineTo(xPos + rayWidthBottom, rayHeight);
    ctx.lineTo(xPos - rayWidthBottom, rayHeight);
    ctx.closePath();
    
    ctx.fillStyle = rayGradient;
    ctx.fill();
  }
  
  const waveCount = 3;
  for (let i = 0; i < waveCount; i++) {
    const time = globalTime * 0.03 + i * Math.PI;
    const yBase = H * (0.3 + i * 0.25);
    
    ctx.beginPath();
    ctx.moveTo(0, yBase);
    for (let x = 0; x < W; x += 20) {
      const primaryWave = 10 * Math.sin((x / W) * Math.PI * 6 + time * 0.5);
      const secondaryWave = 5 * Math.sin((x / W) * Math.PI * 12 + time * 0.7);
      const y = yBase + primaryWave + secondaryWave;
      ctx.lineTo(x, y);
    }
    const waveGradient = ctx.createLinearGradient(0, yBase - 15, 0, yBase + 15);
    waveGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    waveGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.03 - i * 0.005})`);
    waveGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.strokeStyle = waveGradient;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  const floatingParticleCount = 20;
  for (let i = 0; i < floatingParticleCount; i++) {
    const xPos = W * ((i / floatingParticleCount) + 0.2 * Math.sin(globalTime * 0.02 + i));
    const yPos = H * ((i % 5) / 5 + 0.1 * Math.cos(globalTime * 0.03 + i * 2));
    const size = Math.max(0.5, 1.5 + Math.sin(xPos * 0.01) + Math.cos(yPos * 0.01));
    
    ctx.beginPath();
    ctx.arc(xPos, yPos, size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 255, 255, ${0.02 + 0.01 * Math.sin(globalTime * 0.1 + i)})`;
    ctx.fill();
  }
  
  ctx.restore();
}

/***********************************************************************
 * INTERACTION
 ***********************************************************************/
function onCanvasClick(e){
  let rect= canvas.getBoundingClientRect();
  let mx= e.clientX- rect.left, my= e.clientY- rect.top;
  for(let crab of population){
    let dx= mx- crab.x, dy= my- crab.y;
    if(dx*dx + dy*dy<= CONFIG.CRAB_RADIUS* CONFIG.CRAB_RADIUS){
      crab.selected= !crab.selected;
      break;
    }
  }
  updateBreedButton();
}

function updateBreedButton(){
  let sel = population.filter(c => c.selected).length;
  let btn = document.getElementById("breedBtn");
  let info = document.getElementById("infoPanel");
  
  if(sel >= 2){
    btn.style.display = "block";
    info.textContent = `Selected ${sel} crabs - Ready to breed!`;
    btn.style.animation = "pulseButton 1.5s infinite ease-in-out";
    
    if (!document.querySelector("style").textContent.includes("@keyframes pulseButton")) {
      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
        @keyframes pulseButton {
          0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
          50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 6px 20px rgba(75,108,183,0.5); }
        }
      `;
      document.head.appendChild(styleSheet);
    }
  } else if(sel === 1) {
    let crab = population.find(c => c.selected);
    if (crab) {
      let dragMod = Utils.getFormattedGene(crab.genotype, Utils.GENE.DRAG_MOD);
      let rotDragMod = Utils.getFormattedGene(crab.genotype, Utils.GENE.ROT_DRAG_MOD);
      let elasticity = Utils.getFormattedGene(crab.genotype, Utils.GENE.ELASTICITY);
      let torqueEff = Utils.getFormattedGene(crab.genotype, Utils.GENE.TORQUE_EFF);
      let powerRatio = Utils.getFormattedGene(crab.genotype, Utils.GENE.POWER_RATIO);
      
      info.innerHTML = `
        <div style="font-weight:bold;margin-bottom:5px;color:#8CD5FF">Selected Crab Traits</div>
        <div style="display:grid;grid-template-columns:auto auto;gap:4px;font-size:0.85em">
          <div>Streamlining:</div> 
          <div style="color:${dragMod < 1 ? '#8eff8e' : '#ffcf8e'}">${dragMod < 1 ? 'High' : 'Low'} (${dragMod})</div>
          
          <div>Rotation:</div> 
          <div style="color:${rotDragMod < 1 ? '#8effee' : '#d8ff8e'}">${rotDragMod < 1 ? 'Quick' : 'Stable'} (${rotDragMod})</div>
          
          <div>Elasticity:</div> 
          <div style="color:${elasticity > 1 ? '#ff9e8e' : '#a8ff8e'}">${elasticity > 1 ? 'Bouncy' : 'Absorbing'} (${elasticity})</div>
          
          <div>Torque:</div> 
          <div style="color:${torqueEff > 1 ? '#8eadff' : '#ffe78e'}">${torqueEff > 1 ? 'High' : 'Standard'} (${torqueEff})</div>
          
          <div>Power:</div> 
          <div style="color:${powerRatio > 1.2 ? '#ff8ee3' : '#8effba'}">${powerRatio > 1.2 ? 'Strong' : 'Balanced'} (${powerRatio})</div>
        </div>
        <div style="font-size:0.8em;margin-top:5px;opacity:0.8">Select one more crab to breed</div>
      `;
      
      btn.style.display = "none";
      if (btn.style.animation) btn.style.animation = "none";
    } else {
      info.textContent = `Selected 1 crab - need at least 2 to breed`;
      btn.style.display = "none";
      if (btn.style.animation) btn.style.animation = "none";
    }
  } else {
    btn.style.display = "none";
    if (btn.style.animation) btn.style.animation = "none";
    info.textContent = "Click crabs to select (min 2 to breed)";
  }
}

/***********************************************************************
 * MAIN LOOP
 ***********************************************************************/
function mainLoop(){
  globalTime+= CONFIG.TIME_STEP;
  updateMovement();
  drawWorld();
  requestAnimationFrame(mainLoop);
}
</script>
</body>
</html>
